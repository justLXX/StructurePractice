## 方法一
遍历所有的节点，并将每一个节点存入`map`,当`map`中存在重复元素时说明有环
时间复杂度O(n) ，空间复杂度O(n)

## 方法二
快慢指针，龟兔赛跑，设置一个每次走2步的快指针，以及一个每次走一步的慢指针，
当两者相遇的时候，说明有环。
    
### Q1： 为什么快慢指针相遇就说明有环
A1：类比操场跑步，只要一直跑下去，快慢肯定会相遇，
所以说一定有环。
### Q2：操场快慢一定会相遇，但是链表中快慢指针也一定会相遇吗？
>| 链表是有节点的，会不会出现正好快指针超过慢指针的时候， 正好
> 快指针跳到了慢指针后面，然后没有发生重合（指向同一位置）

A2：首先先解释为什么链表有环，快慢指针一定会相遇
假设快指针，每次走2步，慢指针每次走1步。
当慢指针进入环中(此时快指针一定在环中)，当快指针在快要追上慢指针的时候，
一定存在两种情况，

   1. 快指针下一次移动，和慢指针下一次重合。
   2. 快指针下一次移动，到了慢指针当前位置。 
   
情况一两者重合，情况二两者将在下一次移动时重合。
因为快指针移动速度是2，所有不会出现，当前快指针孩子慢指针前一个位置，
下一次移动就到慢指针后面的位置去了。

### Q3：环入口
**先说结论，当快慢指针相遇后，我们将快指针重置回head头节点（或者重新设立一个位于head的指针），与慢指针同速率移动，二者相遇的地方就是环入口。**

证明：
将链表分段，从开头到环入口的距离为L，快慢指针在第t次移动后相遇的位置为X（从环入口开始数），从X位置继续前进，到达环入口的距离记为Y，则有下面的关系：

1. 快指针走过的距离为2*t = L+n*(X+Y)+X, n为双指针相遇前快指针在环内循环的圈数
2. 慢指针走过的距离为t = L+X

联立式子1和式子2，得到：0 = -L+n*(X+Y)-X => L = n*(X+Y)-X，且n必定是大于等于1的（快指针必然绕过1圈才能到达慢指针的后面，才有机会与慢指针相遇）

右边的式子，如果我们再减去一个Y，就会变成(n-1)*(X+Y),正好是完整的环长度，走过Y个距离，应该正好回到环入口，我们设环入口的位置为0，则有L-Y=0，得出L=Y，这意味着，快慢指针相遇的位置出发到达环入口的距离，就是从头节点出发到达环入口的距离。

因此，如果我们设一个指针从头节点走，而另一个指针从位置X开始走，二者走过L个距离，应该正好到达环入口。


#### Q4：为什么快指针要移动2格，移动3格，4格不行吗？
A4：当然可以更快，但是快指针不是越快越好。如果它移动的速度超过了环的长度Q，那么它每次都会走超过环长度的步数（假设为n），那走n步与走n%Q步是等价的，因为它绕了好几圈，回到了环入口，最终也只比它之前的位置多走了n%Q步。如果n%Q==1，那快指针实际上和慢指针的速度是一样的，一旦错过，就永远不会相遇了。之所以设置成2，是因为单向链表的环的长度最少为3，两个节点是无法形成环的。
https://blog.csdn.net/cyoushika_Nara/article/details/121941587
